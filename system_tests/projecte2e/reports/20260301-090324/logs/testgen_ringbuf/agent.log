üåø Entering garden: /Users/ivo/selfware/system_tests/projecte2e/work/testgen_ringbuf

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ  ‚öôÔ∏è SELFWARE WORKSHOP [YOLO]                              ‚îÇ
‚îÇ  üåø Tending: testgen_ringbuf
‚îÇ  üß≠ Remote ¬∑ 0 tasks completed
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ


‚öôÔ∏è Headless Mode

ü¶ä Selfware starting task...
Task: You are writing tests for a ring buffer implementation in the current directory.

The RingBuffer<T> implementation is complete and correct but has ZERO tests.

Acceptance criteria:
1. Write at least 15 test functions in a #[cfg(test)] mod tests block.
2. Cover: new(), push, pop, peek, len, is_empty, is_full, capacity, clear, iter, drain, extend.
3. Test edge cases: empty buffer operations, single-element buffer, overflow/wraparound.
4. Test that push returns the overwritten element when buffer is full.
5. Test iterator correctness after multiple wraparounds.
6. All tests must pass.

Process:
- Read the implementation carefully.
- Write comprehensive tests.
- Run cargo test to verify all pass.

Provide a short summary of what changed.
üìä [1/2] Planning [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%
üìä [2/2] Executing [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 50% ETA: ~2s
üìù Step 1 Executing...
üìù Step 2 Executing...
<tool>
<name=file_read</name>
<arguments>{"path": "./src/lib.rs"}</arguments>
</tool>
üìù Step 3 Executing...
Now I understand the implementation. Let me write comprehensive tests covering all the required functionality:

<tool>
<name=file_edit</name>
<arguments>{"path": "./src/lib.rs", "old_str": "// NO TESTS - the agent must write them", "new_str": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(5);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        assert_eq!(buf.capacity(), 5);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_push_pop_single() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(10);\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.peek(), Some(&10));\n        assert_eq!(buf.pop(), Some(10));\n        assert_eq!(buf.len(), 0);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_push_overwrites_when_full() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert!(buf.is_full());\n        assert_eq!(buf.len(), 3);\n        \n        // Push should overwrite oldest (1) and return it\n        let overwritten = buf.push(4);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.peek(), Some(&2)); // 2 is now oldest\n        \n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_fifo_order() {\n        let mut buf = RingBuffer::new(4);\n        for i in 0..4 {\n            buf.push(i);\n        }\n        for i in 0..4 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n    }\n\n    #[test]\n    fn test_peek_does_not_remove() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        assert_eq!(buf.peek(), Some(&42));\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.pop(), Some(42));\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_clear() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..5 {\n            buf.push(i);\n        }\n        buf.clear();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_single() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(7);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![7]);\n    }\n\n    #[test]\n    fn test_iter_multiple() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..5 {\n            buf.push(i * 10);\n        }\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![0, 10, 20, 30, 40]);\n    }\n\n    #[test]\n    fn test_iter_after_wraparound() {\n        let mut buf = RingBuffer::new(4);\n        // Fill and drain some\n        for i in 0..4 {\n            buf.push(i);\n        }\n        buf.pop(); // Remove 0\n        buf.pop(); // Remove 1\n        // Add more to cause wraparound\n        buf.push(10);\n        buf.push(11);\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 10, 11]);\n    }\n\n    #[test]\n    fn test_iter_multiple_wraparounds() {\n        let mut buf = RingBuffer::new(3);\n        // Do multiple cycles of push/pop\n        for _ in 0..6 {\n            buf.push(1);\n            buf.push(2);\n            buf.push(3);\n            buf.pop();\n            buf.pop();\n        }\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 3, 3]);\n    }\n\n    #[test]\n    fn test_drain() {\n        let mut buf = RingBuffer::new(4);\n        for i in 0..4 {\n            buf.push(i);\n        }\n        let drained = buf.drain();\n        assert_eq!(drained, vec![0, 1, 2, 3]);\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained = buf.drain();\n        assert!(drained.is_empty());\n    }\n\n    #[test]\n    fn test_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(3)); // 1,2 overwritten\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_capacity_one() {\n        let mut buf = RingBuffer::new(1);\n        assert!(buf.is_empty());\n        assert!(buf.is_full());\n        \n        let overwritten = buf.push(100);\n        assert_eq!(overwritten, None);\n        assert!(buf.is_full());\n        \n        let overwritten = buf.push(200);\n        assert_eq!(overwritten, Some(100));\n        assert!(buf.is_full());\n        \n        assert_eq!(buf.pop(), Some(200));\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_push_pop_alternating() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_multiple_overwrites() {\n        let mut buf = RingBuffer::new(3);\n        for i in 0..10 {\n            buf.push(i);\n        }\n        // Only last 3 should remain\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(7));\n        assert_eq!(buf.pop(), Some(8));\n        assert_eq!(buf.pop(), Some(9));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_ref_mutability() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        // Test that iter returns references\n        for item in buf.iter() {\n            let _: &i32 = item;\n        }\n    }\n\n    #[test]\n    fn test_is_full_and_is_empty() {\n        let mut buf = RingBuffer::new(3);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        \n        buf.push(1);\n        assert!(!buf.is_empty());\n        assert!(!buf.is_full());\n        \n        buf.push(2);\n        assert!(!buf.is_empty());\n        assert!(!buf.is_full());\n        \n        buf.push(3);\n        assert!(!buf.is_empty());\n        assert!(buf.is_full());\n        \n        buf.pop();\n        assert!(!buf.is_empty());\n        assert!(!buf.is_full());\n    }\n\n    #[test]\n    fn test_clear_preserves_capacity() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..10 {\n            buf.push(i);\n        }\n        buf.clear();\n        assert_eq!(buf.capacity(), 10);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_large_buffer_operations() {\n        let mut buf = RingBuffer::new(100);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        assert!(buf.is_full());\n        \n        // Overwrite half\n        for i in 100..200 {\n            buf.push(i);\n        }\n        \n        assert_eq!(buf.len(), 100);\n        assert_eq!(buf.pop(), Some(100)); // First remaining\n        assert_eq!(buf.pop(), Some(101));\n    }\n\n    #[test]\n    fn test_string_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(\"hello\".to_string());\n        buf.push(\"world\".to_string());\n        buf.push(\"rust\".to_string());\n        \n        let overwritten = buf.push(\"overflow\".to_string());\n        assert_eq!(overwritten, Some(\"hello\".to_string()));\n        \n        assert_eq!(buf.pop(), Some(\"world\".to_string()));\n        assert_eq!(buf.pop(), Some(\"rust\".to_string()));\n        assert_eq!(buf.pop(), Some(\"overflow\".to_string()));\n    }\n\n    #[test]\n    fn test_clone_and_drop_behavior() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        \n        // Clone should preserve state\n        let buf_clone = RingBuffer {\n            buffer: buf.buffer.clone(),\n            head: buf.head,\n            tail: buf.tail,\n            len: buf.len,\n            capacity: buf.capacity,\n        };\n        \n        assert_eq!(buf_clone.len(), 2);\n        assert_eq!(buf_clone.pop(), Some(1));\n        assert_eq!(buf_clone.pop(), Some(2));\n    }\n\n    #[test]\n    fn test_iter_consumption() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..5 {\n            buf.push(i);\n        }\n        \n        let mut iter = buf.iter();\n        assert_eq!(iter.next(), Some(&0));\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), Some(&3));\n        assert_eq!(iter.next(), Some(&4));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_drain_empty_after() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_push_pop_stress() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..100 {\n            buf.push(i);\n            if i >= 10 {\n                let _ = buf.pop();\n            }\n        }\n        assert_eq!(buf.len(), 10);\n        // Last 10 items should remain\n        for expected in 90..100 {\n            assert_eq!(buf.pop(), Some(expected));\n        }\n    }\n\n    #[test]\n    fn test_iter_with_single_element() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(42);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![42]);\n    }\n\n    #[test]\n    fn test_peek_empty_buffer() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_pop_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_extend_empty_iterator() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(std::iter::empty::<i32>());\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_capacity_boundary() {\n        let buf = RingBuffer::new(7);\n        assert_eq!(buf.capacity(), 7);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_order_after_multiple_wraps() {\n        let mut buf = RingBuffer::new(3);\n        // Multiple full cycles\n        for cycle in 0..5 {\n            for i in 0..3 {\n                buf.push(cycle * 10 + i);\n            }\n        }\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        // Should have last 3 items: 41, 42, 43 (from cycle 4)\n        assert_eq!(items, vec![41, 42, 43]);\n    }\n\n    #[test]\n    fn test_clear_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        buf.clear(); // Should not panic\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_empty_after_full_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_push_returns_overwritten_correctly() {\n        let mut buf = RingBuffer::new(2);\n        assert_eq!(buf.push(1), None); // Not full\n        assert_eq!(buf.push(2), None); // Not full\n        assert_eq!(buf.push(3), Some(1)); // Overwrites 1\n        assert_eq!(buf.push(4), Some(2)); // Overwrites 2\n        assert_eq!(buf.push(5), Some(3)); // Overwrites 3\n    }\n\n    #[test]\n    fn test_mixed_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_char_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push('a');\n        buf.push('b');\n        buf.push('c');\n        \n        let items: Vec<char> = buf.iter().cloned().collect();\n        assert_eq!(items, vec!['a', 'b', 'c']);\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(vec![1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_array_ref() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(&[10, 20, 30][..]);\n        assert_eq!(buf.len(), 3);\n    }\n\n    #[test]\n    fn test_iter_with_large_capacity() {\n        let mut buf = RingBuffer::new(50);\n        for i in 0..50 {\n            buf.push(i);\n        }\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items.len(), 50);\n        assert_eq!(items[0], 0);\n        assert_eq!(items[49], 49);\n    }\n\n    #[test]\n    fn test_pop_after_multiple_pushes() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4); // Overwrites 1\n        \n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_peek_after_push_pop_mixed() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n        buf.push(3);\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_iter_with_single_wraparound() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.pop(); // Remove 1\n        buf.pop(); // Remove 2\n        buf.push(5);\n        buf.push(6);\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_capacity_one_overflow() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        let overwritten = buf.push(2);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.pop(), Some(2));\n    }\n\n    #[test]\n    fn test_iter_with_empty_after_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.pop();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_overwrite() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_clear_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_iter_with_all_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        \n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_drain_with_partial_fill() {\n        let‚ö†Ô∏è Recovering from error: Streaming failed: Stream error: error decoding response body. Non-streaming fallback request also failed
üìù Step 3 Executing...
<tool>
<name=file_read</name>
<arguments>{"path": "./src/lib.rs"}</arguments>
</tool>
üìù Step 4 Executing...
Now I understand the RingBuffer implementation. Let me write comprehensive tests covering all the required functionality:

<tool>
<name=file_edit</name>
<arguments>{"path": "./src/lib.rs", "old_str": "// NO TESTS - the agent must write them", "new_str": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(5);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        assert_eq!(buf.capacity(), 5);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_new_min_capacity() {\n        let buf: RingBuffer<i32> = RingBuffer::new(1);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert_eq!(buf.capacity(), 1);\n    }\n\n    #[test]\n    fn test_push_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(10);\n        assert_eq!(buf.len(), 1);\n        assert!(!buf.is_empty());\n        assert_eq!(buf.peek(), Some(&10));\n    }\n\n    #[test]\n    fn test_push_multiple_elements() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.peek(), Some(&1));\n    }\n\n    #[test]\n    fn test_pop_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.pop(), None);\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_pop_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        assert_eq!(buf.pop(), Some(42));\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_pop_multiple_elements_fifo() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_push_overwrites_oldest_when_full() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert!(buf.is_full());\n        let overwritten = buf.push(4);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_push_multiple_overwrites() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4); // overwrites 1\n        buf.push(5); // overwrites 2\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_peek_does_not_remove() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(100);\n        buf.push(200);\n        assert_eq!(buf.peek(), Some(&100));\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.peek(), Some(&100));\n        assert_eq!(buf.len(), 2);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![42]);\n    }\n\n    #[test]\n    fn test_iter_multiple_elements() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_iter_after_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4); // wraps around, overwrites 1\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_multiple_wraparounds() {\n        let mut buf = RingBuffer::new(3);\n        for i in 1..=6 {\n            buf.push(i);\n        }\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained = buf.drain();\n        assert!(drained.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_all_elements() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3]);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_drain_after_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_clear_empty() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_all_elements() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_clear_after_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n        assert_eq!(buf.capacity(), 3);\n    }\n\n    #[test]\n    fn test_extend_empty_buffer() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        assert_eq!(buf.len(), 3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_extend_from_iterator() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend(1..=3);\n        assert_eq!(buf.len(), 3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_capacity_unchanged_after_operations() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.capacity(), 5);\n        buf.push(4);\n        buf.push(5);\n        assert_eq!(buf.capacity(), 5);\n        buf.push(6); // overwrites\n        assert_eq!(buf.capacity(), 5);\n    }\n\n    #[test]\n    fn test_fifo_order_preserved() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..10 {\n            buf.push(i);\n        }\n        for i in 0..10 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n    }\n\n    #[test]\n    fn test_push_pop_alternating() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        assert_eq!(buf.pop(), Some(2));\n        buf.push(3);\n        buf.push(4);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_peek_after_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n        buf.push(3);\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_iter_consumed_after_full_cycle() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let mut iter = buf.iter();\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), Some(&3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_multiple_drains() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained1 = buf.drain();\n        assert_eq!(drained1, vec![1, 2, 3]);\n        buf.push(4);\n        buf.push(5);\n        let drained2 = buf.drain();\n        assert_eq!(drained2, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_large_capacity() {\n        let mut buf = RingBuffer::new(1000);\n        for i in 0..1000 {\n            buf.push(i);\n        }\n        assert!(buf.is_full());\n        let overwritten = buf.push(1000);\n        assert_eq!(overwritten, Some(0));\n        assert_eq!(buf.len(), 1000);\n        assert_eq!(buf.peek(), Some(&1));\n    }\n\n    #[test]\n    fn test_string_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(\"hello\".to_string());\n        buf.push(\"world\".to_string());\n        assert_eq!(buf.pop(), Some(\"hello\".to_string()));\n        buf.push(\"rust\".to_string());\n        let items: Vec<String> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![\"world\".to_string(), \"rust\".to_string()]);\n    }\n\n    #[test]\n    fn test_struct_elements() {\n        #[derive(Debug, PartialEq, Clone)]\n        struct Point { x: i32, y: i32 }\n        let mut buf = RingBuffer::new(3);\n        buf.push(Point { x: 1, y: 2 });\n        buf.push(Point { x: 3, y: 4 });\n        assert_eq!(buf.pop(), Some(Point { x: 1, y: 2 }));\n        buf.push(Point { x: 5, y: 6 });\n        let items: Vec<Point> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![Point { x: 3, y: 4 }, Point { x: 5, y: 6 }]);\n    }\n\n    #[test]\n    fn test_clear_then_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        buf.clear();\n        assert!(buf.is_empty());\n        buf.extend([10, 20, 30]);\n        assert_eq!(buf.len(), 3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![10, 20, 30]);\n    }\n\n    #[test]\n    fn test_push_pop_same_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_single_element_buffer() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(42);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![42]);\n        assert_eq!(buf.pop(), Some(42));\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_push_returns_overwritten_element() {\n        let mut buf = RingBuffer::new(2);\n        assert_eq!(buf.push(1), None);\n        assert_eq!(buf.push(2), None);\n        assert_eq!(buf.push(3), Some(1));\n        assert_eq!(buf.push(4), Some(2));\n    }\n\n    #[test]\n    fn test_is_full_and_is_empty_consistency() {\n        let mut buf = RingBuffer::new(3);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        buf.push(1);\n        assert!(!buf.is_empty());\n        assert!(!buf.is_full());\n        buf.push(2);\n        assert!(!buf.is_empty());\n        assert!(!buf.is_full());\n        buf.push(3);\n        assert!(!buf.is_empty());\n        assert!(buf.is_full());\n    }\n\n    #[test]\n    fn test_len_matches_element_count() {\n        let mut buf = RingBuffer::new(5);\n        assert_eq!(buf.len(), 0);\n        buf.push(1);\n        assert_eq!(buf.len(), 1);\n        buf.push(2);\n        assert_eq!(buf.len(), 2);\n        buf.push(3);\n        assert_eq!(buf.len(), 3);\n        buf.pop();\n        assert_eq!(buf.len(), 2);\n        buf.push(4);\n        buf.push(5);\n        assert_eq!(buf.len(), 4);\n    }\n\n    #[test]\n    fn test_iter_does_not_modify_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let _items: Vec<&i32> = buf.iter().collect();\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_drain_does_not_modify_capacity() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..5 {\n            buf.push(i);\n        }\n        buf.drain();\n        assert_eq!(buf.capacity(), 10);\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_complex_wraparound_sequence() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(5);\n        assert_eq!(buf.pop(), Some(2));\n        buf.push(6);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_after_many_wraparounds() {\n        let mut buf = RingBuffer::new(3);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![97, 98, 99]);\n    }\n\n    #[test]\n    fn test_extend_with_empty_iterator() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(std::iter::empty::<i32>());\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_larger_iterator() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(0..10);\n        assert_eq!(buf.len(), 3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![7, 8, 9]);\n    }\n\n    #[test]\n    fn test_mixed_operations() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        buf.push(4);\n        buf.push(5);\n        assert_eq!(buf.len(), 5);\n        assert!(buf.is_full());\n        buf.pop();\n        buf.pop();\n        assert_eq!(buf.len(), 3);\n        buf.extend([6, 7, 8, 9]);\n        assert_eq!(buf.len(), 5);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![5, 6, 7, 8, 9]);\n    }\n\n    #[test]\n    fn test_clear_resets_all_state() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        assert_eq!(buf.peek(), None);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_capacity_one_element() {\n        let mut buf = RingBuffer::new(1);\n        assert!(buf.is_empty());\n        buf.push(1);\n        assert!(buf.is_full());\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.peek(), Some(&1));\n        let overwritten = buf.push(2);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.peek(), Some(&2));\n        assert_eq!(buf.pop(), Some(2));\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_next_returns_same_as_peek() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let mut iter = buf.iter();\n        assert_eq!(iter.next(), buf.peek());\n        iter.next();\n        iter.next();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_pop_empty_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_extend_then_iter() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([10, 20, 30]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![10, 20, 30]);\n    }\n\n    #[test]\n    fn test_push_pop_iter_consistency() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        buf.pop();\n        buf.pop();\n        buf.push(6);\n        buf.push(7);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5, 6, 7]);\n    }\n\n    #[test]\n    fn test_drain_then_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3]);\n        buf.push(4);\n        buf.push(5);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_char_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push('a');\n        buf.push('b');\n        buf.push('c');\n        let items: Vec<char> = buf.iter().cloned().collect();\n        assert_eq!(items, vec!['a', 'b', 'c']);\n    }\n\n    #[test]\n    fn test_multiple_clear_operations() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3]);\n    }\n\n    #[test]\n    fn test_iter_after_pop_and_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_capacity_not_affected_by_operations() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..20 {\n            buf.push(i);\n        }\n        assert_eq!(buf.capacity(), 10);\n        assert_eq!(buf.len(), 10);\n        buf.clear();\n        assert_eq!(buf.capacity(), 10);\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_with_i64_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(100i64);\n        buf.push(200i64);\n        buf.push(300i64);\n        let items: Vec<i64> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![100, 200, 300]);\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend(vec![1, 2, 3, 4, 5]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_f32_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1.5f32);\n        buf.push(2.5f32);\n        buf.push(3.5f32);\n        let items: Vec<f32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![1.5, 2.5, 3.5]);\n    }\n\n    #[test]\n    fn test_push_pop_iter_with_f64() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1.1);\n        buf.push(2.2);\n        buf.push(3.3);\n        buf.pop();\n        buf.push(4.4);\n        let items: Vec<f64> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2.2, 3.3, 4.4]);\n    }\n\n    #[test]\n    fn test_clear_then_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_bool_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(true);\n        buf.push(false);\n        buf.push(true);\n        let items: Vec<bool> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![true, false, true]);\n    }\n\n    #[test]\n    fn test_extend_with_range() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(1..=3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_iter_with_option_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(Some(1));\n        buf.push(None);\n        buf.push(Some(2));\n        let items: Vec<Option<i32>> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![Some(1), None, Some(2)]);\n    }\n\n    #[test]\n    fn test_drain_with_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained = buf.drain();\n        assert!(drained.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_vec_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(vec![1, 2]);\n        buf.push(vec![3, 4]);\n        buf.push(vec![5, 6]);\n        let items: Vec<Vec<i32>> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![vec![1, 2], vec![3, 4], vec![5, 6]]);\n    }\n\n    #[test]\n    fn test_push_pop_iter_with_string_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(\"a\".to_string());\n        buf.push(\"b\".to_string());\n        buf.pop();\n        buf.push(\"c\".to_string());\n        let items: Vec<String> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![\"b\".to_string(), \"c\".to_string()]);\n    }\n\n    #[test]\n    fn test_iter_with_tuple_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push((1, \"a\"));\n        buf.push((2, \"b\"));\n        buf.push((3, \"c\"));\n        let items: Vec<(i32, &str)> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n    }\n\n    #[test]\n    fn test_extend_with_iterator_overwriting() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5, 6]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_nested_struct() {\n        #[derive(Debug, PartialEq, Clone)]\n        struct Inner { value: i32 }\n        #[derive(Debug, PartialEq, Clone)]\n        struct Outer { inner: Inner }\n        let mut buf = RingBuffer::new(3);\n        buf.push(Outer { inner: Inner { value: 1 } });\n        buf.push(Outer { inner: Inner { value: 2 } });\n        let items: Vec<Outer> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![\n            Outer { inner: Inner { value: 1 } },\n            Outer { inner: Inner { value: 2 } },\n        ]);\n    }\n\n    #[test]\n    fn test_clear_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4]);\n        buf.clear();\n        buf.extend([5, 6]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_large_buffer() {\n        let mut buf = RingBuffer::new(100);\n        for i in 0..50 {\n            buf.push(i);\n        }\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items.len(), 50);\n        assert_eq!(items[0], 0);\n        assert_eq!(items[49], 49);\n    }\n\n    #[test]\n    fn test_push_pop_iter_with_mixed_operations() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        buf.extend([6, 7]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5, 6, 7]);\n    }\n\n    #[test]\n    fn test_iter_with_single_element_wraparound() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        buf.push(2);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2]);\n    }\n\n    #[test]\n    fn test_drain_with_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_empty_iterator_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(std::iter::empty());\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_single_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.pop();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_multiple_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_then_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4]);\n        buf.clear();\n        buf.extend([5]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.drain();\n        buf.extend([4, 5]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_push_pop_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        buf.extend([4]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.push(4);\n        buf.pop();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.pop();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_push_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend([2, 3, 4]);\n        buf.pop();\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        buf.pop();\n        buf.extend([3, 4]);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4]);\n        buf.pop();\n        buf.extend([5, 6]);\n        let items: Vec<i32> =
Received shutdown signal, exiting gracefully...
 buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_push_pop_push_pop_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        let items: Vec<i32> = buf.iter().cloned().collect();\n        assert_eq!(items, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_multiple_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1]);\n        buf.extend([2]);\n        buf.extend([3]);\n        buf.extend([4]);\n        let items: Vec<i32> = buf.iter().cloned().Shutdown grace period expired, forcing exit.
