# Selfware Agentic Benchmark Suite (SAB) Report

## Summary

| Metric | Value |
|--------|-------|
| Date | 20260301-014451 |
| Model | Qwen/Qwen3-Coder-Next-FP8 |
| Endpoint | https://crazyshit.ngrok.io/v1 |
| Max Context | 1,010,000 tokens |
| Total Scenarios | 12 |
| Completed | 12 |
| Passed (tests green) | 12/12 |
| Average Score | 96/100 |
| Overall Rating | **üå∏ BLOOM** |
| Total Duration | 8m 51s |

### Rating Distribution

| Rating | Count | Description |
|--------|-------|-------------|
| üå∏ BLOOM | 10 | Ship it. Model handles this reliably. |
| üåø GROW | 2 | Usable with occasional human review. |
| ü•Ä WILT | 0 | Model struggles. Needs prompt tuning. |
| ‚ùÑÔ∏è FROST | 0 | Not ready for this task class. |

## Detailed Results

| Scenario | Difficulty | Score | Rating | Duration | Baseline | Post | Agent Exit | Timeout | Changed | Errors |
|----------|-----------|-------|--------|----------|----------|------|------------|---------|---------|--------|
| `codegen_task_runner` | hard | 100/100 | üå∏ BLOOM | 64s | 101 | 0 | 0 | 0 | 0 | 4 |
| `easy_calculator` | easy | 100/100 | üå∏ BLOOM | 48s | 101 | 0 | 0 | 0 | 0 | 4 |
| `easy_string_ops` | easy | 100/100 | üå∏ BLOOM | 77s | 101 | 0 | 0 | 0 | 0 | 0 |
| `expert_async_race` | expert | 100/100 | üå∏ BLOOM | 54s | 101 | 0 | 0 | 0 | 0 | 7 |
| `hard_event_bus` | hard | 100/100 | üå∏ BLOOM | 93s | 101 | 0 | 0 | 0 | 0 | 4 |
| `hard_scheduler` | hard | 100/100 | üå∏ BLOOM | 50s | 101 | 0 | 0 | 0 | 0 | 6 |
| `medium_bitset` | medium | 100/100 | üå∏ BLOOM | 79s | 101 | 0 | 0 | 0 | 0 | 1 |
| `medium_json_merge` | medium | 100/100 | üå∏ BLOOM | 46s | 101 | 0 | 0 | 0 | 0 | 0 |
| `perf_optimization` | hard | 100/100 | üå∏ BLOOM | 348s | 124 | 0 | 0 | 0 | 0 | 0 |
| `security_audit` | hard | 100/100 | üå∏ BLOOM | 100s | 101 | 0 | 0 | 0 | 0 | 5 |
| `refactor_monolith` | medium | 80/100 | üåø GROW | 161s | 0 | 0 | 0 | 0 | 0 | 10 |
| `testgen_ringbuf` | medium | 80/100 | üåø GROW | 366s | 0 | 0 | 0 | 0 | 0 | 2 |

## Category Breakdown

### Easy (2/2 passed, avg 100/100)

- `easy_calculator`: üå∏ 100/100 in 48s
- `easy_string_ops`: üå∏ 100/100 in 77s

### Medium (4/4 passed, avg 90/100)

- `medium_bitset`: üå∏ 100/100 in 79s
- `medium_json_merge`: üå∏ 100/100 in 46s
- `refactor_monolith`: üåø 80/100 in 161s
- `testgen_ringbuf`: üåø 80/100 in 366s

### Hard (5/5 passed, avg 100/100)

- `codegen_task_runner`: üå∏ 100/100 in 64s
- `hard_event_bus`: üå∏ 100/100 in 93s
- `hard_scheduler`: üå∏ 100/100 in 50s
- `perf_optimization`: üå∏ 100/100 in 348s
- `security_audit`: üå∏ 100/100 in 100s

### Expert (1/1 passed, avg 100/100)

- `expert_async_race`: üå∏ 100/100 in 54s

## Error Highlights

### easy_calculator
```
50:2. **`divide`** - panics on division by zero instead of returning `None`
62:<arguments>{"path": "./src/lib.rs", "old_str": "pub fn divide(a: i64, b: i64) -> Option<i64> {\n    // BUG: division by zero currently panics instead of returning None\n    Some(a / b)\n}", "new_str": "pub fn divide(a: i64, b: i64) -> Option<i64> {\n    if b == 0 {\n        None\n    } else {\n        Some(a / b)\n    }\n}"}</arguments>
90:2. **`divide`** - Added check for division by zero to return `None` instead of panicking
103:2. **`divide`** - Added check for division by zero to return `None` instead of panicking
```

### easy_string_ops
No significant errors captured.

### medium_json_merge
No significant errors captured.

### medium_bitset
```
14:The implementation has several logic bugs that cause tests to fail or panic.
```

### hard_scheduler
```
19:4. next_run_at must not panic on overflow (return None instead).
64:   - Handle overflow without panicking
99:- Fixed overflow panic by using `checked_add()` instead of `+` operator
106:4. ‚úÖ next_run_at returns None on overflow (no panic)
120:- Fixed overflow panic by using `checked_add()` instead of `+` operator
127:4. ‚úÖ next_run_at returns None on overflow (no panic)
```

### hard_event_bus
```
85:The display format is close but the test expects a different format. Looking at the error message, it expects `Event { topic: "user.login", seq: 7 }` but my implementation produces `Event { topic: "user.login", seq: 7 }` with escaped quotes. Let me check the exact expected format:
145:All tests pass. Let me run cargo clippy one more time to confirm there are no errors:
152:All tests pass and clippy shows only a warning (not an error) about adding a `Default` implementation, which is optional and not required by the task.
170:Final answer: All tests pass and clippy shows only a warning (not an error) about adding a `Default` implementation, which is optional and not required by the task.
```

### expert_async_race
```
47:3. **Missing `running` decrement in `fail()`**: Only increments failed
69:<arguments>{"new_str": "    /// Mark the current task as failed.\n    pub async fn fail(&self) {\n        let mut state = self.state.lock().await;\n        state.running -= 1;\n        state.failed += 1;\n    }", "old_str": "    /// Mark the current task as failed.\n    ///\n    /// BUG: Increments failed but forgets to decrement running.\n    pub async fn fail(&self) {\n        let mut state = self.state.lock().await;\n        // BUG: missing `state.running -= 1;`\n        state.failed += 1;\n    }", "path": "./src/lib.rs"}</arguments>
74:<arguments>{"new_str": "    /// Return a snapshot of (running, completed, failed).\n    pub async fn snapshot(&self) -> (u32, u32, u32) {\n        let state = self.state.lock().await;\n        (state.running, state.completed, state.failed)\n    }", "old_str": "    /// Return a snapshot of (running, completed, failed).\n    ///\n    /// BUG: Split lock - reads running under one lock acquisition,\n    /// then reads completed and failed under another. The state can\n    /// change between the two reads, giving an inconsistent view.\n    pub async fn snapshot(&self) -> (u32, u32, u32) {\n        let running = {\n            let state = self.state.lock().await;\n            state.running\n        };\n        // ^^^ Lock dropped. State can mutate here.\n        let (completed, failed) = {\n            let state = self.state.lock().await;\n            (state.completed, state.failed)\n        };\n        (running, completed, failed)\n    }", "path": "./src/lib.rs"}</arguments>
101:3. **Missing `running` decrement in `fail()`**: Added `state.running -= 1` before incrementing failed.
103:4. **Split-lock in `snapshot()`**: Read all three counters (running, completed, failed) under a single lock acquisition to ensure consistency.
116:3. **Missing `running` decrement in `fail()`**: Added `state.running -= 1` before incrementing failed.
118:4. **Split-lock in `snapshot()`**: Read all three counters (running, completed, failed) under a single lock acquisition to ensure consistency.
```

### security_audit
```
22:5. Implement handle_error_secure that returns generic error messages without internal paths.
63:<arguments>{"new_str": "use std::fs;\nuse std::path::Path;\nuse std::process::Command;\n\n// ---------------------------------------------------------------------------\n// 1. Path Traversal\n// ---------------------------------------------------------------------------\n\n/// VULNERABLE: Naively joins base_dir and filename without canonicalization.\n/// An attacker can supply \"../../../etc/passwd\" to escape the base directory.\npub fn read_user_file(base_dir: &str, filename: &str) -> Result<String, String> {\n    let path = format!(\"{}/{}\", base_dir, filename);\n    fs::read_to_string(&path).map_err(|e| e.to_string())\n}\n\n/// SECURE: Must canonicalize the resolved path and verify it stays within base_dir.\npub fn read_user_file_secure(base_dir: &str, filename: &str) -> Result<String, String> {\n    let base_path = Path::new(base_dir);\n    let resolved_path = base_path.join(filename);\n    \n    // Canonicalize both paths to resolve any .. or . components\n    let canonical_base = base_path\n        .canonicalize()\n        .map_err(|e| format!(\"Failed to canonicalize base directory: {}\", e))?;\n    let canonical_resolved = resolved_path\n        .canonicalize()\n        .map_err(|e| format!(\"Failed to canonicalize resolved path: {}\", e))?;\n    \n    // Verify the resolved path is within the base directory\n    if !canonical_resolved.starts_with(&canonical_base) {\n        return Err(\"Path traversal detected: resolved path is outside base directory\".to_string());\n    }\n    \n    fs::read_to_string(&canonical_resolved).map_err(|e| e.to_string())\n}", "old_str": "use std::fs;\nuse std::path::Path;\nuse std::process::Command;\n\n// ---------------------------------------------------------------------------\n// 1. Path Traversal\n// ---------------------------------------------------------------------------\n\n/// VULNERABLE: Naively joins base_dir and filename without canonicalization.\n/// An attacker can supply \"../../../etc/passwd\" to escape the base directory.\npub fn read_user_file(base_dir: &str, filename: &str) -> Result<String, String> {\n    let path = format!(\"{}/{}\", base_dir, filename);\n    fs::read_to_string(&path).map_err(|e| e.to_string())\n}\n\n/// SECURE: Must canonicalize the resolved path and verify it stays within base_dir.\npub fn read_user_file_secure(base_dir: &str, filename: &str) -> Result<String, String> {\n    todo!(\"Implement secure version with path canonicalization and prefix validation\")\n}", "path": "./src/lib.rs"}</arguments>
87:Now let me implement `handle_error_secure` that returns generic error messages without internal paths:
91:<arguments>{"new_str": "/// SECURE: Must return a generic error message without revealing internal paths.\npub fn handle_error_secure(_path: &str) -> String {\n    \"Error: file not found\".to_string()\n}", "old_str": "/// SECURE: Must return a generic error message without revealing internal paths.\npub fn handle_error_secure(path: &str) -> String {\n    todo!(\"Implement secure version that returns generic error messages without internal paths\")\n}", "path": "./src/lib.rs"}</arguments>
133:5. **`handle_error_secure`** - Information leak protection by returning a generic error message without revealing internal file paths.
```

### perf_optimization
No significant errors captured.

### codegen_task_runner
```
68:<arguments>{"content": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum Priority {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum Status {\n    Pending,\n    Running,\n    Completed,\n    Failed(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Task {\n    pub id: u64,\n    pub name: String,\n    pub priority: Priority,\n    pub status: Status,\n    pub tags: Vec<String>,\n    pub created_at: u64, // unix timestamp\n}\n\npub struct TaskManager {\n    tasks: Vec<Task>,\n    next_id: u64,\n}\n\nimpl TaskManager {\n    pub fn new() -> Self {\n        TaskManager {\n            tasks: Vec::new(),\n            next_id: 1,\n        }\n    }\n\n    pub fn add(&mut self, name: &str, priority: Priority) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        let task = Task {\n            id,\n            name: name.to_string(),\n            priority,\n            status: Status::Pending,\n            tags: Vec::new(),\n            created_at: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        };\n        self.tasks.push(task);\n        id\n    }\n\n    pub fn get(&self, id: u64) -> Option<&Task> {\n        self.tasks.iter().find(|t| t.id == id)\n    }\n\n    pub fn remove(&mut self, id: u64) -> Option<Task> {\n        if let Some(pos) = self.tasks.iter().position(|t| t.id == id) {\n            Some(self.tasks.remove(pos))\n        } else {\n            None\n        }\n    }\n\n    pub fn update_status(&mut self, id: u64, status: Status) -> bool {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            task.status = status;\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn add_tag(&mut self, id: u64, tag: &str) -> bool {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            task.tags.push(tag.to_string());\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn by_status(&self, status: &Status) -> Vec<&Task> {\n        self.tasks\n            .iter()\n            .filter(|t| &t.status == status)\n            .collect()\n    }\n\n    pub fn by_priority(&self, priority: &Priority) -> Vec<&Task> {\n        self.tasks\n            .iter()\n            .filter(|t| &t.priority == priority)\n            .collect()\n    }\n\n    pub fn by_tag(&self, tag: &str) -> Vec<&Task> {\n        self.tasks\n            .iter()\n            .filter(|t| t.tags.iter().any(|t| t == tag))\n            .collect()\n    }\n\n    pub fn sorted_by_priority(&self) -> Vec<&Task> {\n        let mut result: Vec<&Task> = self.tasks.iter().collect();\n        result.sort_by(|a, b| {\n            let priority_order = |p: &Priority| match p {\n                Priority::Critical => 0,\n                Priority::High => 1,\n                Priority::Medium => 2,\n                Priority::Low => 3,\n            };\n            priority_order(&a.priority).cmp(&priority_order(&b.priority))\n        });\n        result\n    }\n\n    pub fn to_json(&self) -> String {\n        serde_json::to_string(self).expect(\"serialization should succeed\")\n    }\n\n    pub fn from_json(json: &str) -> Result<Self, String> {\n        serde_json::from_str(json).map_err(|e| e.to_string())\n    }\n\n    pub fn cleanup_completed(&mut self, older_than: u64) -> usize {\n        let before = self.tasks.len();\n        self.tasks.retain(|t| {\n            !(matches!(t.status, Status::Completed) && t.created_at < older_than)\n        });\n        before - self.tasks.len()\n    }\n}", "path": "./src/lib.rs"}</arguments>
77:‚ïë Status: ‚úó FAILED                        ‚ïë
85:‚ïë   ‚Ä¢ Fix type errors before proceeding
89:I need to check the compilation error. Let me run cargo check to see the specific issue:
```

### testgen_ringbuf
```
39:<arguments>{"path": "./src/lib.rs", "old_str": "// NO TESTS - the agent must write them", "new_str": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(5);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        assert_eq!(buf.capacity(), 5);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_push_pop_single() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(10);\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.peek(), Some(&10));\n        assert_eq!(buf.pop(), Some(10));\n        assert_eq!(buf.len(), 0);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_push_multiple() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.peek(), Some(&1));\n    }\n\n    #[test]\n    fn test_fifo_order() {\n        let mut buf = RingBuffer::new(5);\n        for i in 1..=5 {\n            buf.push(i);\n        }\n        for i in 1..=5 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_push_overflow_returns_overwritten() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.len(), 3);\n        assert!(buf.is_full());\n        // Pushing 4 should overwrite 1\n        let overwritten = buf.push(4);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_peek_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_pop_empty() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_single() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&42]);\n    }\n\n    #[test]\n    fn test_iter_multiple() {\n        let mut buf = RingBuffer::new(5);\n        for i in 1..=4 {\n            buf.push(i);\n        }\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4]);\n    }\n\n    #[test]\n    fn test_drain() {\n        let mut buf = RingBuffer::new(4);\n        for i in 1..=3 {\n            buf.push(i);\n        }\n        let drained: Vec<_> = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3]);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained: Vec<_> = buf.drain();\n        assert_eq!(drained.len(), 0);\n    }\n\n    #[test]\n    fn test_clear() {\n        let mut buf = RingBuffer::new(5);\n        for i in 1..=5 {\n            buf.push(i);\n        }\n        assert_eq!(buf.len(), 5);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_wraparound_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.peek(), Some(&2));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_multiple_wraparounds_iter() {\n        let mut buf = RingBuffer::new(4);\n        // Fill and drain once\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.pop();\n        buf.pop();\n        // Fill again\n        buf.push(5);\n        buf.push(6);\n        // Buffer now has: 3, 4, 5, 6 (but 3,4 were overwritten)\n        // Actually: after pop twice, tail moves, then push 5,6\n        // buffer: [None, None, 3, 4] -> pop -> [None, None, None, 4] -> pop -> [None, None, None, None]\n        // push 5,6: [5, 6, None, None] with head at 2\n        // Let me trace more carefully:\n        // Initial: head=0, tail=0, len=0\n        // push 1: head=1, tail=0, len=1, buffer[0]=1\n        // push 2: head=2, tail=0, len=2, buffer[1]=2\n        // push 3: head=3, tail=0, len=3, buffer[2]=3\n        // push 4: head=0, tail=0, len=4, buffer[3]=4 (full)\n        // pop: tail=1, len=3, returns 1\n        // pop: tail=2, len=2, returns 2\n        // push 5: head=1, tail=2, len=3, buffer[0]=5 (overwrites nothing since not full)\n        // push 6: head=2, tail=2, len=4, buffer[1]=6 (full)\n        // iter should give: 3, 4, 5, 6\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_capacity_one() {\n        let mut buf = RingBuffer::new(1);\n        assert_eq!(buf.capacity(), 1);\n        assert!(buf.is_empty());\n        buf.push(100);\n        assert!(buf.is_full());\n        assert_eq!(buf.len(), 1);\n        let overwritten = buf.push(200);\n        assert_eq!(overwritten, Some(100));\n        assert_eq!(buf.pop(), Some(200));\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_push_pop_alternating() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_peek_multiple_times() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.peek(), Some(&1));\n        assert_eq!(buf.peek(), Some(&1)); // peek doesn't consume\n        assert_eq!(buf.len(), 2);\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_iter_does_not_consume() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        let items1: Vec<_> = buf.iter().collect();\n        let items2: Vec<_> = buf.iter().collect();\n        assert_eq!(items1, items2);\n        assert_eq!(buf.len(), 2);\n    }\n\n    #[test]\n    fn test_drain_preserves_order_after_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4); // overwrites 1\n        buf.push(5); // overwrites 2\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_extend_empty_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(std::iter::empty::<i32>());\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_large_buffer_operations() {\n        let mut buf = RingBuffer::new(100);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        assert!(buf.is_full());\n        for i in 0..50 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        assert_eq!(buf.len(), 50);\n        for i in 100..150 {\n            buf.push(i);\n        }\n        assert_eq!(buf.len(), 100);\n        for i in 50..100 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        for i in 100..150 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_string_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(\"hello\".to_string());\n        buf.push(\"world\".to_string());\n        assert_eq!(buf.peek(), Some(&\"hello\".to_string()));\n        assert_eq!(buf.pop(), Some(\"hello\".to_string()));\n        assert_eq!(buf.pop(), Some(\"world\".to_string()));\n    }\n\n    #[test]\n    fn test_struct_buffer() {\n        #[derive(Debug, PartialEq)]\n        struct Point { x: i32, y: i32 }\n        let mut buf = RingBuffer::new(3);\n        buf.push(Point { x: 1, y: 2 });\n        buf.push(Point { x: 3, y: 4 });\n        assert_eq!(buf.pop(), Some(Point { x: 1, y: 2 }));\n        assert_eq!(buf.pop(), Some(Point { x: 3, y: 4 }));\n    }\n\n    #[test]\n    fn test_overwrite_and_verify_all() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4); // overwrite 1\n        buf.push(5); // overwrite 2\n        buf.push(6); // overwrite 3\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), Some(6));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_after_many_pushes_pops() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_clear_preserves_capacity() {\n        let mut buf = RingBuffer::new(10);\n        for i in 1..=10 {\n            buf.push(i);\n        }\n        buf.clear();\n        assert_eq!(buf.capacity(), 10);\n        assert_eq!(buf.len(), 0);\n        buf.push(42);\n        assert_eq!(buf.len(), 1);\n    }\n\n    #[test]\n    fn test_push_pop_stress() {\n        let mut buf = RingBuffer::new(5);\n        for round in 0..10 {\n            for i in 0..5 {\n                buf.push(round * 5 + i);\n            }\n            for _ in 0..3 {\n                buf.pop();\n            }\n        }\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.pop(), Some(43));\n        assert_eq!(buf.pop(), Some(44));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_is_full_and_push() {\n        let mut buf = RingBuffer::new(3);\n        assert!(!buf.is_full());\n        buf.push(1);\n        assert!(!buf.is_full());\n        buf.push(2);\n        assert!(!buf.is_full());\n        buf.push(3);\n        assert!(buf.is_full());\n        buf.push(4);\n        assert!(buf.is_full());\n    }\n\n    #[test]\n    fn test_peek_after_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.push(2);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n        buf.pop();\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_drain_after_wraparound() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5); // overwrites 1\n        buf.push(6); // overwrites 2\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_none_values() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(Some(1));\n        buf.push(None);\n        buf.push(Some(2));\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&Some(1), &None, &Some(2)]);\n    }\n\n    #[test]\n    fn test_capacity_constraint_enforced() {\n        let buf = RingBuffer::new(1);\n        assert_eq!(buf.capacity(), 1);\n    }\n\n    #[test]\n    #[should_panic(expected = \"capacity must be > 0\")]\n    fn test_new_zero_capacity_panics() {\n        let _buf: RingBuffer<i32> = RingBuffer::new(0);\n    }\n\n    #[test]\n    fn test_extend_with_iterator() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend((1..=3).map(|x| x * 10));\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(10));\n        assert_eq!(buf.pop(), Some(20));\n        assert_eq!(buf.pop(), Some(30));\n    }\n\n    #[test]\n    fn test_multiple_clears() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        assert!(buf.is_empty());\n        buf.push(3);\n        buf.clear();\n        assert!(buf.is_empty());\n        buf.push(4);\n        assert_eq!(buf.len(), 1);\n    }\n\n    #[test]\n    fn test_iter_len_consistency() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..=5 {\n            buf.push(i);\n            let iter_count = buf.iter().count();\n            assert_eq!(iter_count, buf.len());\n        }\n    }\n\n    #[test]\n    fn test_pop_empty_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_push_pop_single_element_buffer() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        assert_eq!(buf.pop(), Some(2));\n    }\n\n    #[test]\n    fn test_iter_with_single_element() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(42);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&42]);\n        assert_eq!(buf.len(), 1);\n    }\n\n    #[test]\n    fn test_drain_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(100);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![100]);\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_peek_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_iter_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_partial_then_full() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2]);\n        assert_eq!(buf.len(), 2);\n        buf.extend([3, 4, 5]);\n        assert_eq!(buf.len(), 4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_push_pop_interleaved() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_capacity_not_affected_by_operations() {\n        let mut buf = RingBuffer::new(10);\n        for i in 1..=20 {\n            buf.push(i);\n        }\n        assert_eq!(buf.capacity(), 10);\n        assert_eq!(buf.len(), 10);\n        buf.clear();\n        assert_eq!(buf.capacity(), 10);\n    }\n\n    #[test]\n    fn test_iter_reference_semantics() {\n        let mut buf = RingBuffer::new(3);\n        let s = \"hello\".to_string();\n        buf.push(s);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items[0], &\"hello\".to_string());\n        assert_eq!(buf.len(), 1);\n    }\n\n    #[test]\n    fn test_drain_reference_semantics() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2]);\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_multiple_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4]);\n        buf.extend([5]);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.drain(), vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_large_buffer() {\n        let mut buf = RingBuffer::new(100);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 100);\n        for (i, &val) in items.iter().enumerate() {\n            assert_eq!(val, &i);\n        }\n    }\n\n    #[test]\n    fn test_pop_after_many_pushes() {\n        let mut buf = RingBuffer::new(3);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(97));\n        assert_eq!(buf.pop(), Some(98));\n        assert_eq!(buf.pop(), Some(99));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_peek_does_not_change_state() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.peek();\n        buf.peek();\n        buf.peek();\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n    }\n\n    #[test]\n    fn test_extend_overwrites_correctly() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5, 6]);\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), Some(6));\n    }\n\n    #[test]\n    fn test_iter_after_extend_and_pop() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_empty_after_full_then_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained1 = buf.drain();\n        assert_eq!(drained1, vec![1, 2, 3]);\n        let drained2 = buf.drain();\n        assert_eq!(drained2.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.drain(), vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_consistency_with_drain() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        let iter_items: Vec<_> = buf.iter().collect();\n        let mut drain_items = buf.drain();\n        assert_eq!(iter_items.len(), drain_items.len());\n        for (a, b) in iter_items.iter().zip(drain_items.iter()) {\n            assert_eq!(a, b);\n        }\n    }\n\n    #[test]\n    fn test_push_pop_capacity_one() {\n        let mut buf = RingBuffer::new(1);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        buf.push(1);\n        assert!(!buf.is_empty());\n        assert!(buf.is_full());\n        assert_eq!(buf.pop(), Some(1));\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n    }\n\n    #[test]\n    fn test_iter_with_overwritten_elements() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_peek_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.extend([3, 4]);\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_drain_with_overwritten_elements() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3, 4, 5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_after_clear_and_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5]);\n    }\n\n    #[test]\n    fn test_pop_after_extend_then_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        assert_eq!(buf.pop(), Some(1));\n        buf.extend([3, 4]);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_mixed_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_capacity_various_sizes() {\n        for cap in [1, 2, 3, 5, 8, 16, 32, 64, 128] {\n            let buf = RingBuffer::new(cap);\n            assert_eq!(buf.capacity(), cap);\n        }\n    }\n\n    #[test]\n    fn test_extend_with_empty_iterator() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(std::iter::empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_count_matches_len() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..5 {\n            buf.push(i);\n            assert_eq!(buf.iter().count(), buf.len());\n        }\n    }\n\n    #[test]\n    fn test_peek_after_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_drain_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.drain();\n        buf.extend([4, 5]);\n        assert_eq!(buf.len(), 2);\n        assert_eq!(buf.drain(), vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_after_multiple_drains() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2]);\n        buf.drain();\n        buf.extend([3, 4]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4]);\n    }\n\n    #[test]\n    fn test_clear_then_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_clear_then_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_push_pop_round_trip() {\n        let mut buf = RingBuffer::new(3);\n        for i in 0..10 {\n            buf.push(i);\n            if buf.len() >= 2 {\n                buf.pop();\n            }\n        }\n        assert!(buf.len() <= 3);\n    }\n\n    #[test]\n    fn test_iter_with_char_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push('a');\n        buf.push('b');\n        buf.push('c');\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&'a', &'b', &'c']);\n    }\n\n    #[test]\n    fn test_extend_with_range() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(1..=4);\n        assert_eq!(buf.len(), 4);\n        assert_eq!(buf.drain(), vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_i64_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1000000i64);\n        buf.push(2000000i64);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1000000i64, &2000000i64]);\n    }\n\n    #[test]\n    fn test_drain_preserves_order_with_wraparound() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6, 7]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6, 7]);\n    }\n\n    #[test]\n    fn test_iter_with_bool_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(true);\n        buf.push(false);\n        buf.push(true);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&true, &false, &true]);\n    }\n\n    #[test]\n    fn test_push_pop_alternating_single_element() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        buf.push(2);\n        assert_eq!(buf.pop(), Some(2));\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_iter_with_float_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1.5);\n        buf.push(2.5);\n        buf.push(3.5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1.5, &2.5, &3.5]);\n    }\n\n    #[test]\n    fn test_clear_then_extend_then_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5, 6]);\n        assert_eq!(buf.drain(), vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_vec_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(vec![1, 2]);\n        buf.push(vec![3, 4]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&vec![1, 2], &vec![3, 4]]);\n    }\n\n    #[test]\n    fn test_drain_with_vec_buffer() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(vec![1]);\n        buf.push(vec![2]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![vec![1], vec![2]]);\n    }\n\n    #[test]\n    fn test_iter_with_hashmap_buffer() {\n        use std::collections::HashMap;\n        let mut buf = RingBuffer::new(3);\n        let mut map1 = HashMap::new();\n        map1.insert(1, \"a\");\n        let mut map2 = HashMap::new();\n        map2.insert(2, \"b\");\n        buf.push(map1);\n        buf.push(map2);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 2);\n    }\n\n    #[test]\n    fn test_push_pop_stress_large() {\n        let mut buf = RingBuffer::new(50);\n        for i in 0..200 {\n            buf.push(i);\n        }\n        assert_eq!(buf.len(), 50);\n        for i in 0..50 {\n            assert_eq!(buf.pop(), Some(i + 150));\n        }\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_string_buffer_large() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..5 {\n            buf.push(format!(\"item{}\", i));\n        }\n        let items: Vec<_> = buf.iter().collect();\n        for i in 0..5 {\n            assert_eq!(items[i], &format!(\"item{}\", i));\n        }\n    }\n\n    #[test]\n    fn test_extend_with_overwrite_then_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_pop_after_extend_with_overwrite() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4, 5]);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_after_pop_then_extend() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_then_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.drain();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_with_single_element_after_wraparound() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4]);\n    }\n\n    #[test]\n    fn test_clear_then_extend_then_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5]);\n    }\n\n    #[test]\n    fn test_iter_with_empty_buffer() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_with_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained: Vec<_> = buf.drain();\n        assert_eq!(drained.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_then_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_with_large_capacity() {\n        let mut buf = RingBuffer::new(1000);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 100);\n        for (i, &val) in items.iter().enumerate() {\n            assert_eq!(val, &i);\n        }\n    }\n\n    #[test]\n    fn test_pop_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_peek_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_iter_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        let drained: Vec<_> = buf.drain();\n        assert_eq!(drained.len(), 0);\n    }\n\n    #[test]\n    fn test_push_pop_iter_consistency() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let iter_items: Vec<_> = buf.iter().collect();\n        let mut drain_items = buf.drain();\n        assert_eq!(iter_items.len(), drain_items.len());\n        for (i, item) in iter_items.iter().enumerate() {\n            assert_eq!(*item, &drain_items[i]);\n        }\n    }\n\n    #[test]\n    fn test_extend_then_drain_consistency() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        let iter_items: Vec<_> = buf.iter().collect();\n        let drain_items: Vec<_> = buf.drain();\n        assert_eq!(iter_items.len(), drain_items.len());\n        for (i, item) in iter_items.iter().enumerate() {\n            assert_eq!(*item, &drain_items[i]);\n        }\n    }\n\n    #[test]\n    fn test_multiple_extend_then_iter() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4]);\n        buf.extend([5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_iter_with_overwrite_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_overwrite_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.extend([4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_then_extend() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_then_extend() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_clear_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_clear_then_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_multiple_clears() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        buf.clear();\n        buf.extend([6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&6]);\n    }\n\n    #[test]\n    fn test_drain_with_multiple_clears() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5]);\n        buf.clear();\n        buf.extend([6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![6]);\n    }\n\n    #[test]\n    fn test_iter_with_alternating_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.pop();\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4]);\n    }\n\n    #[test]\n    fn test_drain_with_alternating_push_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.pop();\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_large_overwrite() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items.len(), 5);\n        for (i, &val) in items.iter().enumerate() {\n            assert_eq!(val, &(95 + i));\n        }\n    }\n\n    #[test]\n    fn test_drain_with_large_overwrite() {\n        let mut buf = RingBuffer::new(5);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        let drained = buf.drain();\n        assert_eq!(drained, vec![95, 96, 97, 98, 99]);\n    }\n\n    #[test]\n    fn test_iter_with_single_element_buffer() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3]);\n    }\n\n    #[test]\n    fn test_drain_with_single_element_buffer() {\n        let mut buf = RingBuffer::new(1);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3]);\n    }\n\n    #[test]\n    fn test_iter_with_peek_consistency() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        let first_item = buf.peek();\n        let iter_items: Vec<_> = buf.iter().collect();\n        assert_eq!(first_item, iter_items.first().copied());\n    }\n\n    #[test]\n    fn test_drain_with_peek_consistency() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend([1, 2, 3]);\n        let first_item = buf.peek().cloned();\n        let mut drained = buf.drain();\n        assert_eq!(first_item, drained.first().cloned());\n    }\n\n    #[test]\n    fn test_iter_with_extend_then_pop() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.extend([5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_then_pop() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.extend([5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_then_extend_then_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6, 7]);\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5, &6, &7]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_then_extend_then_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6, 7]);\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4, 5, 6, 7]);\n    }\n\n    #[test]\n    fn test_iter_with_multiple_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2, 3]);\n        buf.extend([4, 5]);\n        buf.extend([6, 7, 8, 9, 10]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5, &6, &7, &8, &9, &10]);\n    }\n\n    #[test]\n    fn test_drain_with_multiple_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2, 3]);\n        buf.extend([4, 5]);\n        buf.extend([6, 7, 8, 9, 10]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_over_capacity() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&6, &7, &8, &9, &10]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_over_capacity() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![6, 7, 8, 9, 10]);\n    }\n\n    #[test]\n    fn test_iter_with_push_pop_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3]);\n    }\n\n    #[test]\n    fn test_drain_with_push_pop_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_push_pop_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_push_pop_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_clear_push_clear_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        buf.clear();\n        buf.push(4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4]);\n    }\n\n    #[test]\n    fn test_drain_with_clear_push_clear_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        buf.clear();\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4]);\n    }\n\n    #[test]\n    fn test_iter_with_push_clear_push_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        buf.push(4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4]);\n    }\n\n    #[test]\n    fn test_drain_with_push_clear_push_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_clear_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.clear();\n        buf.extend([4, 5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_push_extend_pop() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.extend([2, 3, 4]);\n        buf.pop();\n        buf.extend([5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_push_extend_pop() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.extend([2, 3, 4]);\n        buf.pop();\n        buf.extend([5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.push(6);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_extend_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.push(6);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4, 5]);\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4, 5]);\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_push_push_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.pop();\n        buf.push(4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4]);\n    }\n\n    #[test]\n    fn test_drain_with_push_push_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.pop();\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_push_pop_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_push_pop_push() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.push(4);\n        buf.pop();\n        buf.push(5);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_pop_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_push_extend_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.extend([2, 3]);\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_push_extend_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.extend([2, 3]);\n        buf.extend([4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_push_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.extend([4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_push_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.extend([4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_extend_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4]);\n        buf.push(5);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_extend_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.extend([3, 4]);\n        buf.push(5);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        buf.pop();\n        buf.pop();\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        buf.pop();\n        buf.pop();\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_push_push_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3]);\n    }\n\n    #[test]\n    fn test_drain_with_push_push_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_pop_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.extend([5, 6]);\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.extend([5, 6]);\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_push_pop_push_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.pop();\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3]);\n    }\n\n    #[test]\n    fn test_drain_with_push_pop_push_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.pop();\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_extend_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2]);\n        buf.extend([3, 4, 5]);\n        buf.extend([6, 7, 8, 9, 10]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5, &6, &7, &8, &9, &10]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_extend_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2]);\n        buf.extend([3, 4, 5]);\n        buf.extend([6, 7, 8, 9, 10]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n    }\n\n    #[test]\n    fn test_iter_with_push_extend_push_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.push(1);\n        buf.extend([2, 3]);\n        buf.push(4);\n        buf.extend([5, 6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_push_extend_push_extend() {\n        let mut buf = RingBuffer::new(10);\n        buf.push(1);\n        buf.extend([2, 3]);\n        buf.push(4);\n        buf.extend([5, 6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_push_extend_push() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.extend([4, 5]);\n        buf.push(6);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_push_extend_push() {\n        let mut buf = RingBuffer::new(10);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.extend([4, 5]);\n        buf.push(6);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_pop_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_pop_extend_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4]);\n        buf.pop();\n        buf.pop();\n        buf.extend([5, 6]);\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        buf.pop();\n        buf.pop();\n        buf.pop();\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_pop_pop_pop() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3, 4, 5]);\n        buf.pop();\n        buf.pop();\n        buf.pop();\n        let drained = buf.drain();\n        assert_eq!(drained, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_push_push_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.extend([3, 4, 5]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4, &5]);\n    }\n\n    #[test]\n    fn test_drain_with_push_push_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.extend([3, 4, 5]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_push_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.push(4);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&1, &2, &3, &4]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_push_push() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2]);\n        buf.push(3);\n        buf.push(4);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.extend([6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&2, &3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_pop_extend_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.extend([6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.pop();\n        buf.extend([6]);\n        let items: Vec<_> = buf.iter().collect();\n        assert_eq!(items, vec![&3, &4, &5, &6]);\n    }\n\n    #[test]\n    fn test_drain_with_extend_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend([1, 2, 3]);\n        buf.pop();\n        buf.extend([4, 5]);\n        buf.pop();\n        buf.extend([6]);\n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_with_push_pop_extend_pop_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.pop();\n        buf.extend([2, 3]);\nüìù Step 3 Executing...
47:I have one failing test. Let me analyze the issue - the test `test_push_pop_stress` has a logic error. When `i < 5`, the buffer isn't full yet, so no element gets overwritten. Let me fix this test:
```

### refactor_monolith
```
102:‚ïë Status: ‚úó FAILED                        ‚ïë
111:‚ïë   ‚Ä¢ Fix type errors before proceeding
126:‚ïë Status: ‚úó FAILED                        ‚ïë
142:‚ïë   ‚Ä¢ Fix type errors before proceeding
164:‚ïë Status: ‚úó FAILED                        ‚ïë
172:‚ïë   ‚Ä¢ Fix type errors before proceeding
187:‚ïë Status: ‚úó FAILED                        ‚ïë
194:‚ïë   ‚Ä¢ Fix type errors before proceeding
202:<arguments>{"content": "use crate::store::KvStore;\n\n// ---------------------------------------------------------------------------\n// Serialization methods for KvStore\n// ---------------------------------------------------------------------------\n\nimpl KvStore {\n    // -- Serialization ------------------------------------------------------\n\n    /// Serialize the store to a JSON string.\n    pub fn to_json(&self) -> String {\n        serde_json::to_string(self).expect(\"serialization should not fail\")\n    }\n\n    /// Deserialize a store from a JSON string.\n    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {\n        serde_json::from_str(json)\n    }\n}\n", "path": "./src/serialization.rs"}</arguments>
254:Let me check if there's an issue with the code. Let me run cargo check first to see if there are compilation errors:
```

## Progress Timeline

```
[01:45:41] medium_json_merge: score=100/100 rating=BLOOM duration=46s
[01:45:41] easy_calculator: score=100/100 rating=BLOOM duration=48s
[01:45:44] hard_scheduler: score=100/100 rating=BLOOM duration=50s
[01:46:11] easy_string_ops: score=100/100 rating=BLOOM duration=77s
[01:46:13] medium_bitset: score=100/100 rating=BLOOM duration=79s
[01:46:28] hard_event_bus: score=100/100 rating=BLOOM duration=93s
[01:46:47] expert_async_race: score=100/100 rating=BLOOM duration=54s
[01:47:21] codegen_task_runner: score=100/100 rating=BLOOM duration=64s
[01:47:27] security_audit: score=100/100 rating=BLOOM duration=100s
[01:49:18] refactor_monolith: score=80/100 rating=GROW duration=161s
[01:52:28] testgen_ringbuf: score=80/100 rating=GROW duration=366s
[01:53:40] perf_optimization: score=100/100 rating=BLOOM duration=348s
```

## Artifacts

- Report: `system_tests/projecte2e/reports/20260301-014451/REPORT.md`
- Results: `system_tests/projecte2e/reports/20260301-014451/results/`
- Logs: `system_tests/projecte2e/reports/20260301-014451/logs/<scenario>/`
