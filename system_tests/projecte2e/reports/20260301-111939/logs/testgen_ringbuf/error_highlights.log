44:<arguments>{"new_str": "// NO TESTS - the agent must write them\n\n#[cfg(test)]\nmod tests {\n    use super::RingBuffer;\n\n    #[test]\n    fn test_new_creates_empty_buffer() {\n        let buf: RingBuffer<i32> = RingBuffer::new(5);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.is_empty());\n        assert!(!buf.is_full());\n        assert_eq!(buf.capacity(), 5);\n    }\n\n    #[test]\n    fn test_push_and_pop_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(10);\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.pop(), Some(10));\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_push_returns_overwritten_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        // Buffer is now full\n        assert!(buf.is_full());\n        \n        // Pushing 4 should overwrite 1\n        let overwritten = buf.push(4);\n        assert_eq!(overwritten, Some(1));\n        assert_eq!(buf.len(), 3);\n        \n        // Verify the buffer contains 2, 3, 4\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_peek_returns_oldest_element() {\n        let mut buf = RingBuffer::new(3);\n        assert_eq!(buf.peek(), None);\n        \n        buf.push(100);\n        assert_eq!(buf.peek(), Some(&100));\n        assert_eq!(buf.len(), 1);\n        \n        buf.push(200);\n        assert_eq!(buf.peek(), Some(&100));\n    }\n\n    #[test]\n    fn test_multiple_pushes_and_pops() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        \n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.push(5));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_clear() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.clear();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_empty_buffer() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_returns_items_in_order() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(10);\n        buf.push(20);\n        buf.push(30);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20, 30]);\n    }\n\n    #[test]\n    fn test_iter_after_wraparound() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        // Buffer is full: [1, 2, 3, 4]\n        \n        buf.pop(); // Remove 1\n        buf.pop(); // Remove 2\n        // Now: [3, 4] at positions 2, 3\n        \n        buf.push(5);\n        buf.push(6);\n        // Buffer: [3, 4, 5, 6] with head at 2, tail at 2\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_iter_multiple_wraparounds() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        // Multiple overwrites\n        buf.push(4);\n        buf.push(5);\n        buf.push(6);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_drain() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        let drained = buf.drain();\n        assert_eq!(drained, vec![1, 2, 3]);\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        let drained = buf.drain();\n        assert!(drained.is_empty());\n    }\n\n    #[test]\n    fn test_extend() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(vec![1, 2, 3]);\n        \n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(vec![1, 2, 3, 4, 5]);\n        \n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_is_full() {\n        let mut buf = RingBuffer::new(3);\n        assert!(!buf.is_full());\n        \n        buf.push(1);\n        assert!(!buf.is_full());\n        \n        buf.push(2);\n        assert!(!buf.is_full());\n        \n        buf.push(3);\n        assert!(buf.is_full());\n    }\n\n    #[test]\n    fn test_capacity() {\n        let buf: RingBuffer<i32> = RingBuffer::new(10);\n        assert_eq!(buf.capacity(), 10);\n        \n        let buf2: RingBuffer<String> = RingBuffer::new(1);\n        assert_eq!(buf2.capacity(), 1);\n    }\n\n    #[test]\n    fn test_pop_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.pop(), None);\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_peek_empty_buffer() {\n        let buf: RingBuffer<i32> = RingBuffer::new(3);\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_single_element_buffer_operations() {\n        let mut buf = RingBuffer::new(1);\n        assert!(buf.is_empty());\n        assert!(buf.is_full());\n        \n        buf.push(42);\n        assert!(buf.is_full());\n        assert_eq!(buf.peek(), Some(&42));\n        \n        let overwritten = buf.push(100);\n        assert_eq!(overwritten, Some(42));\n        assert_eq!(buf.pop(), Some(100));\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_large_buffer_operations() {\n        let mut buf = RingBuffer::new(1000);\n        \n        // Fill buffer\n        for i in 0..1000 {\n            buf.push(i);\n        }\n        assert!(buf.is_full());\n        \n        // Verify all items\n        for i in 0..1000 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_does_not_consume() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        \n        // Iterate multiple times\n        let items1: Vec<i32> = buf.iter().map(|x| *x).collect();\n        let items2: Vec<i32> = buf.iter().map(|x| *x).collect();\n        \n        assert_eq!(items1, vec![1, 2]);\n        assert_eq!(items2, vec![1, 2]);\n        assert_eq!(buf.len(), 2);\n    }\n\n    #[test]\n    fn test_push_pop_alternating() {\n        let mut buf = RingBuffer::new(3);\n        \n        buf.push(1);\n        assert_eq!(buf.pop(), Some(1));\n        \n        buf.push(2);\n        buf.push(3);\n        assert_eq!(buf.pop(), Some(2));\n        \n        buf.push(4);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_clear_empty_buffer() {\n        let mut buf: RingBuffer<i32> = RingBuffer::new(5);\n        buf.clear(); // Should not panic\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_drain_clears_buffer() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.drain();\n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_from_iterator() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend((10..15).map(|x| x * 10));\n        \n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.pop(), Some(100));\n        assert_eq!(buf.pop(), Some(200));\n        assert_eq!(buf.pop(), Some(300));\n        assert_eq!(buf.pop(), Some(400));\n        assert_eq!(buf.pop(), Some(500));\n    }\n\n    #[test]\n    fn test_iter_with_strings() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(\"hello\".to_string());\n        buf.push(\"world\".to_string());\n        buf.push(\"test\".to_string());\n        \n        let items: Vec<String> = buf.iter().map(|x| x.clone()).collect();\n        assert_eq!(items, vec![\"hello\", \"world\", \"test\"]);\n    }\n\n    #[test]\n    fn test_push_pop_stress() {\n        let mut buf = RingBuffer::new(10);\n        \n        // Push 100 items with wraparound\n        for i in 0..100 {\n            buf.push(i);\n        }\n        \n        // Should only have last 10 items\n        assert_eq!(buf.len(), 10);\n        for i in 0..10 {\n            assert_eq!(buf.pop(), Some(i + 90));\n        }\n    }\n\n    #[test]\n    fn test_capacity_one() {\n        let mut buf = RingBuffer::new(1);\n        assert_eq!(buf.capacity(), 1);\n        \n        buf.push(1);\n        assert!(buf.is_full());\n        \n        let overwritten = buf.push(2);\n        assert_eq!(overwritten, Some(1));\n        assert!(buf.is_full());\n        \n        assert_eq!(buf.pop(), Some(2));\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.clear();\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.drain();\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_empty_iterator() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(vec![].into_iter());\n        \n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_multiple_overwrites_same_position() {\n        let mut buf = RingBuffer::new(3);\n        \n        // Fill and overwrite multiple times\n        for i in 0..10 {\n            buf.push(i);\n        }\n        \n        // Should have last 3 items\n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(7));\n        assert_eq!(buf.pop(), Some(8));\n        assert_eq!(buf.pop(), Some(9));\n    }\n\n    #[test]\n    fn test_iter_after_multiple_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        \n        buf.pop(); // Remove 1\n        buf.pop(); // Remove 2\n        \n        buf.push(5);\n        buf.push(6);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_peek_does_not_remove() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        \n        assert_eq!(buf.peek(), Some(&42));\n        assert_eq!(buf.len(), 1);\n        \n        assert_eq!(buf.peek(), Some(&42));\n        assert_eq!(buf.len(), 1);\n        \n        assert_eq!(buf.pop(), Some(42));\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_partially_filled_buffer() {\n        let mut buf = RingBuffer::new(5);\n        buf.push(1);\n        buf.push(2);\n        \n        buf.extend(vec![3, 4, 5, 6, 7]);\n        \n        // Should have last 5 items: 3, 4, 5, 6, 7\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), Some(6));\n        assert_eq!(buf.pop(), Some(7));\n    }\n\n    #[test]\n    fn test_clear_preserves_capacity() {\n        let mut buf = RingBuffer::new(10);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.clear();\n        assert_eq!(buf.capacity(), 10);\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_mixed_types() {\n        #[derive(Clone, Debug, PartialEq)]\n        struct Point { x: i32, y: i32 }\n        \n        let mut buf = RingBuffer::new(3);\n        buf.push(Point { x: 1, y: 2 });\n        buf.push(Point { x: 3, y: 4 });\n        buf.push(Point { x: 5, y: 6 });\n        \n        let items: Vec<Point> = buf.iter().map(|x| x.clone()).collect();\n        assert_eq!(items, vec![\n            Point { x: 1, y: 2 },\n            Point { x: 3, y: 4 },\n            Point { x: 5, y: 6 },\n        ]);\n    }\n\n    #[test]\n    fn test_pop_after_multiple_overwrites() {\n        let mut buf = RingBuffer::new(3);\n        \n        // Fill and overwrite\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        \n        // Should have 3, 4, 5\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_large_buffer() {\n        let mut buf = RingBuffer::new(100);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items.len(), 100);\n        assert_eq!(items[0], 0);\n        assert_eq!(items[99], 99);\n    }\n\n    #[test]\n    fn test_extend_overwrites_all() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.extend(vec![10, 20, 30, 40]);\n        \n        // Should have 20, 30, 40 (last 3)\n        assert_eq!(buf.pop(), Some(20));\n        assert_eq!(buf.pop(), Some(30));\n        assert_eq!(buf.pop(), Some(40));\n    }\n\n    #[test]\n    fn test_peek_after_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        \n        assert_eq!(buf.peek(), Some(&1));\n        buf.pop();\n        assert_eq!(buf.peek(), Some(&2));\n        buf.pop();\n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_iter_with_single_element() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(42);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![42]);\n    }\n\n    #[test]\n    fn test_push_pop_capacity_boundary() {\n        let mut buf = RingBuffer::new(5);\n        \n        // Push exactly capacity items\n        for i in 0..5 {\n            buf.push(i);\n        }\n        assert!(buf.is_full());\n        \n        // Pop all\n        for i in 0..5 {\n            assert_eq!(buf.pop(), Some(i));\n        }\n        assert!(buf.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_clear_and_repush() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.clear();\n        buf.push(10);\n        buf.push(20);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20]);\n    }\n\n    #[test]\n    fn test_drain_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.push(5);\n        \n        let drained = buf.drain();\n        assert_eq!(drained, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_and_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        \n        buf.extend(vec![3, 4, 5, 6]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![4, 5, 6]);\n    }\n\n    #[test]\n    fn test_multiple_clears() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        buf.clear();\n        buf.push(4);\n        \n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_iter_with_peek() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        // Peek doesn't affect iteration\n        assert_eq!(buf.peek(), Some(&1));\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_pop_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(vec![1, 2, 3, 4]);\n        \n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n    }\n\n    #[test]\n    fn test_iter_with_mixed_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.pop(); // Remove 1\n        buf.push(4);\n        buf.push(5);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_capacity_one_overflow() {\n        let mut buf = RingBuffer::new(1);\n        \n        let overwritten1 = buf.push(1);\n        assert_eq!(overwritten1, None);\n        \n        let overwritten2 = buf.push(2);\n        assert_eq!(overwritten2, Some(1));\n        \n        let overwritten3 = buf.push(3);\n        assert_eq!(overwritten3, Some(2));\n        \n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_with_empty_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![1]);\n    }\n\n    #[test]\n    fn test_drain_after_multiple_operations() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        buf.pop(); // Remove 1\n        buf.push(5);\n        \n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_all_operations() {\n        let mut buf = RingBuffer::new(4);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.push(4);\n        \n        buf.pop(); // 1\n        buf.pop(); // 2\n        \n        buf.push(5);\n        buf.push(6);\n        \n        buf.clear();\n        \n        buf.push(10);\n        buf.push(20);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20]);\n    }\n\n    #[test]\n    fn test_extend_with_iterator() {\n        let mut buf = RingBuffer::new(5);\n        buf.extend(1..=3);\n        \n        assert_eq!(buf.len(), 3);\n        assert_eq!(buf.pop(), Some(1));\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n    }\n\n    #[test]\n    fn test_iter_with_large_overwrite() {\n        let mut buf = RingBuffer::new(10);\n        for i in 0..100 {\n            buf.push(i);\n        }\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items.len(), 10);\n        assert_eq!(items[0], 90);\n        assert_eq!(items[9], 99);\n    }\n\n    #[test]\n    fn test_pop_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        \n        assert_eq!(buf.pop(), None);\n    }\n\n    #[test]\n    fn test_iter_after_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_peek_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.extend(vec![3, 4]);\n        \n        assert_eq!(buf.peek(), Some(&2));\n    }\n\n    #[test]\n    fn test_drain_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        \n        let drained = buf.drain();\n        assert_eq!(drained, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_peek_and_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        assert_eq!(buf.peek(), Some(&1));\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![2, 3]);\n    }\n\n    #[test]\n    fn test_clear_after_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(vec![1, 2, 3, 4]);\n        buf.clear();\n        \n        assert!(buf.is_empty());\n        assert_eq!(buf.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_with_drain_and_push() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.drain();\n        buf.push(10);\n        buf.push(20);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20]);\n    }\n\n    #[test]\n    fn test_pop_after_extend_with_overflow() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4, 5]);\n        \n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_iter_with_clear_and_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.extend(vec![10, 20, 30]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20, 30]);\n    }\n\n    #[test]\n    fn test_peek_after_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        \n        assert_eq!(buf.peek(), None);\n    }\n\n    #[test]\n    fn test_iter_with_pop_and_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        buf.extend(vec![4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_drain_with_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        \n        let drained = buf.drain();\n        assert!(drained.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_multiple_clears() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.push(2);\n        buf.clear();\n        buf.push(3);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3]);\n    }\n\n    #[test]\n    fn test_pop_after_clear_and_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.extend(vec![10, 20, 30]);\n        \n        assert_eq!(buf.pop(), Some(10));\n        assert_eq!(buf.pop(), Some(20));\n        assert_eq!(buf.pop(), Some(30));\n    }\n\n    #[test]\n    fn test_iter_with_peek_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        assert_eq!(buf.peek(), Some(&1));\n        buf.extend(vec![3, 4]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_extend_with_iter() {\n        let mut buf = RingBuffer::new(4);\n        buf.extend([1, 2].iter().cloned());\n        buf.extend([3, 4, 5].iter().cloned());\n        \n        assert_eq!(buf.len(), 4);\n        assert_eq!(buf.pop(), Some(2));\n        assert_eq!(buf.pop(), Some(3));\n        assert_eq!(buf.pop(), Some(4));\n        assert_eq!(buf.pop(), Some(5));\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![10, 20]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20]);\n    }\n\n    #[test]\n    fn test_clear_with_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        buf.clear();\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_drain_with_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        \n        let drained = buf.drain();\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        \n        assert_eq!(drained, vec![1, 2, 3]);\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.extend(vec![1, 2]);\n        buf.clear();\n        buf.extend(vec![10, 20, 30]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![10, 20, 30]);\n    }\n\n    #[test]\n    fn test_pop_with_iter() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.push(3);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![2, 3]);\n    }\n\n    #[test]\n    fn test_iter_with_clear_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(10);\n        \n        buf.drain();\n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.push(3);\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_clear_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.clear();\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_pop_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.push(10);\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_clear_pop_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![20, 30, 40]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_clear_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_pop_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.pop();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_pop_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_clear_drain_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.clear();\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.push(10);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_clear_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_clear_extend_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_pop_drain() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        buf.drain();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_pop_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.pop();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        buf.extend(vec![20, 30, 40]);\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_clear_drain_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.clear();\n        buf.drain();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_drain_clear_extend() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        buf.extend(vec![3, 4, 5]);\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert_eq!(items, vec![3, 4, 5]);\n    }\n\n    #[test]\n    fn test_iter_with_drain_extend_clear_pop() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.drain();\n        buf.extend(vec![3, 4, 5]);\n        buf.clear();\n        buf.push(10);\n        buf.pop();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_extend_pop_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.extend(vec![2, 3, 4]);\n        buf.pop();\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_pop_extend_drain_clear() {\n        let mut buf = RingBuffer::new(3);\n        buf.push(1);\n        buf.push(2);\n        buf.pop();\n        buf.extend(vec![3, 4, 5]);\n        buf.drain();\n        buf.clear();\n        \n        let items: Vec<i32> = buf.iter().map(|x| *x).collect();\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_iter_with_drain_pop_extend_clear() {\n        let mut buf = RingBuffer::new
